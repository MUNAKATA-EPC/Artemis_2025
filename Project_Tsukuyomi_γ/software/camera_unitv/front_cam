import sensor, image, time, math,lcd
import Maix

from fpioa_manager import fm
from machine import UART
from Maix import GPIO



#定数定義
ANGLE_CONVERSION = 0.28125
GOAL_ANGLE_CONVERSION = 3.55555
WIDTH = const(320)
HEIGHT = const(184)
PROXIMITY_HEIGHT = const(110)
PROXIMITY_CNT_NUM = const(10)

#ホモグラフィー変換行列
homegraphy_matrix = [   [ 5.93750000e+00,  0.00000000e+00,  0.00000000e+00],
                        [ 0.00000000e+00, -6.11111111e+00,  1.46666667e+03],
                        [ 0.00000000e+00,  3.91666667e-01,  1.00000000e+00]]
#センサーの設定
lcd.init(freq=15000000)

sensor.reset(dual_buff=True)
sensor.set_pixformat(sensor.RGB565)#カラースケール
sensor.set_framesize(sensor.QVGA)#解像度Ss
sensor.set_contrast(1)#コントラスト
sensor.set_brightness(2)#明るさ
sensor.set_saturation(3)#彩3~-3
sensor.set_auto_gain(False) # must be turned off for color tracking
sensor.set_auto_exposure(False)
#sensor.set_auto_whitebal(True)
sensor.skip_frames(time = 2000)

#各閾値
ball_thresholds = [(40, 98, -12, 86, 49, 86)]
y_goal_thresholds = [(51, 89, -27, 86, 42, 111)]
b_goal_thresholds = [(0, 100, 127, -128, -60, -96)]
court_thresholds = [(0, 100, -16, -2, -19, 0)]


#変数定義
proximity_cnt = [0] * 7
proximity = [0] * 7


def MatrixMultiply(matrix, vector): #行列の積を計算する関数
    result = [[sum(a * b for a, b in zip(row, col)) for col in zip(*vector)] for row in matrix]
    return result

def CheckGreen(x, y):
    def Check(thresholds, lab):
        l_min, l_max, a_min, a_max, b_min, b_max = thresholds[0]
        return 1 if l_min < lab[0] < l_max and a_min < lab[1] < a_max and b_min < lab[2] < b_max else 0

    bit = []
    for dx in [-3, 0, 3]:
        for dy in [-3, 0, 3]:
            bit.append(Check(court_thresholds, image.rgb_to_lab(img.get_pixel(x + dx, y + dy))))

    return 0 if any(bit) else 1

def HomographyProjection(center_x, center_y): #ホモグラフィー変換をする関数
    #カメラ座標でのコートベクトル
    camera_vector = [[center_x],
                     [center_y],
                     [1       ]]

    #ワールド座標に変換
    coordinate = MatrixMultiply(homegraphy_matrix, camera_vector)
    world_vector = [[coordinate[0][0] / coordinate[2][0]],
                    [coordinate[1][0] / coordinate[2][0]]]
    return world_vector

while True:
    img = sensor.snapshot() #映像の取得

    #ボールを見つける
    ball_rectarray = []
    ball_x = 0
    ball_y = 0
    for blob in img.find_blobs(ball_thresholds, pixel_threshold = 5, area_threshold = 5, merge = True, margin = 10):
        if blob[2] < 150:
            ball_rectarray.append(list(blob.rect()))     #見つかった閾値内のオブジェクトをリストに格納

    try:
        ball_maxrect = max(ball_rectarray, key = lambda x: x[1])    #配列の中から一番画面の下にあるものを選定
        ball_x = ball_maxrect[0] + (ball_maxrect[2] * 0.5)  #中心のx座標の算出
        ball_y = ball_maxrect[1] + (ball_maxrect[3] * 0.5)  #中心のy座標の算出
        img.draw_circle(int(ball_x), int(ball_y), int((ball_maxrect[2] * 0.5 + ball_maxrect[3] * 0.5) * 0.5))

    except ValueError as err:   #オブジェクトがひとつも見つからなかった場合の例外処理
        pass

    #黄色ゴールを見つける
    y_goal_rectarray = []
    y_goal_x = 0
    y_goal_width = 0
    y_goal_hight = 0

    for blob in img.find_blobs(y_goal_thresholds,  pixel_threshold = 100, area_threshold = 100, merge = True, margin = 75):
        y_goal_rectarray.append(list(blob.rect()))     #見つかった閾値内のオブジェクトをリストに格納

    try:
        y_goal_maxrect = max(y_goal_rectarray, key = lambda x: x[2] * x[3])    #配列の中から面積の一番大きい物を選定
        y_goal_x = y_goal_maxrect[0] + (y_goal_maxrect[2] * 0.5)  #中心のx座標の算出
        y_goal_width = y_goal_maxrect[2]
        y_goal_hight = y_goal_maxrect[3]
        img.draw_rectangle(y_goal_maxrect)     #オブジェクトを囲う四角形の描画

    except ValueError as err:   #オブジェクトがひとつも見つからなかった場合の例外処理
        pass

    #青色ゴールを見つける
    b_goal_rectarray = []
    b_goal_x = 0
    b_goal_width = 0
    b_goal_hight = 0

    for blob in img.find_blobs(b_goal_thresholds, pixel_threshold = 100, area_threshold = 100, merge = True, margin = 75):
        b_goal_rectarray.append(list(blob.rect()))     #見つかった閾値内のオブジェクトをリストに格納

    try:
        b_goal_maxrect = min(b_goal_rectarray, key = lambda x: x[2] * x[3])    #配列の中から面積の一番大きい物を選定
        b_goal_x = b_goal_maxrect[0] + (b_goal_maxrect[2] * 0.5)  #中心のx座標の算出
        b_goal_width = b_goal_maxrect[2]
        b_goal_hight = b_goal_maxrect[3]
        img.draw_rectangle(b_goal_maxrect)     #オブジェクトを囲う四角形の描画


    except ValueError as err:   #オブジェクトがひとつも見つからなかった場合の例外処理
        pass

    court_rectarray = []
    court_x = 0
    court_y = 0

    for blob in img.find_blobs(court_thresholds,pixel_threshold = 1000, area_threshold = 1000, merge = True, margin = 1000):
        court_rectarray.append(list(blob.rect()))     #見つかった閾値内のオブジェクトをリストに格納

    try:
        court_maxrect = max(court_rectarray, key = lambda x: x[2] * x[3])  # Y座標が一番大きい要素を選定
        court_x = court_maxrect[0] + (court_maxrect[2] * 0.5)  #中心のx座標の算出
        court_y = court_maxrect[1]
        img.draw_line(0, court_maxrect[1], 320, court_maxrect[1])     #オブジェクトを囲う四角形の描画

    except ValueError as err:   #オブジェクトがひとつも見つからなかった場合の例外処理
        pass

    world_court_vector = HomographyProjection(court_x - 160 ,court_y)

    #コートベクトルの大きさ
    court_dis = int(world_court_vector[1][0] * 0.5)

    #取得した値を変換
    ball_dir = int(ball_x * ANGLE_CONVERSION) #ボールの角度を求める

    #カメラ座標でのボールベクトル

    world_ball_vector = HomographyProjection(ball_x - 160,ball_y)

    #ボールベクトルの大きさ
    ball_dis = int(math.sqrt((world_ball_vector[0][0] - (ball_x - 160) * 0.0625) ** 2 + world_ball_vector[1][0] ** 2) * 2) * (1.0 / (abs(math.cos(math.radians(ball_dir - 45))) ** 0.5))

    y_goal_dir = (int(y_goal_x )/ 320 * 90) - 45
    y_goal_hight = int(y_goal_hight)

    b_goal_dir = int(b_goal_x / GOAL_ANGLE_CONVERSION)
    b_goal_hight = int(b_goal_hight)

    is_goal_front = 0
    own_dir = 0

    if (y_goal_dir == -45):
        y_goal_dir = 255


    if(y_goal_hight > b_goal_hight): #黄ゴールが見つかった時
        is_y_goal = 1
        goal_dir = y_goal_dir
        goal_size = y_goal_hight

    else: #青ゴールが見つかった時
        is_y_goal = 0
        goal_dir = b_goal_dir
        goal_size = b_goal_hight


    print (ball_dis)

    #uart送信

